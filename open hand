from lib_robotis_mod import *
import time
import numpy as np
act_out0 = []
act_out1 = []
class Model_O(OpenHand):
	servo_speed = 1.0
	max_torque = 0.4
	amnt_close = 0.5 #default close position
	max_close = 0.7 #max motor movement from open to close for individual hand

	modes = [True,True,True,True] #True if in position control

	HOLD_TORQUE = 0.2
	OVERSHOOT = 0.15

	#RESET THE MOTOR MINS FOR FASTER INITIALIZATION
	motorDir = [1,1,-1,1] # one finger is opposite due to placement on the openhand base
	motorMin = [0.0,0.22,0.13,0.27]
	motorMax = [motorMin[0]+0.48,motorMin[1]+max_close,motorMin[2]+max_close,motorMin[3]+max_close]

	HAND_HEIGHT = 0.14
	WRIST_OFFSET = -np.pi/4

	def __init__(self,port="/dev/ttyUSB0",s1=2,s2=1,s3=3,s4=4,dyn_model="RX",s1_min=motorMin[0],s2_min=motorMin[1],s3_min=motorMin[2],s4_min=motorMin[3]):
		#s1: adduction/abduction motor for spread
		#s2: forward-driving finger
		#s3: reverse-driving finger
		#s4: thumb
		mot_offset = [s1_min,s2_min,s3_min,s4_min]
		if(mot_offset != self.motorMin):  #update motor mins if initialized to different values
			print ('Setting new motor minimums according to initialization...')
			print (' ')
			self.motorMin = mot_offset
			self.motorMax = [self.motorMin[0]+0.48,self.motorMin[1]+self.max_close,self.motorMin[2]+self.max_close,self.motorMin[3]+self.max_close]
		OpenHand.__init__(self,port,[s1,s2,s3,s4],dyn_model)

	def reset(self):
		self.release()
		time.sleep(0.5)
		self.moveMotor(0,0.)	#moves fingers into lateral pinch mode with fingers orthogonal to thumb

	def release(self):
		self.moveMotor(1,0.)
		self.moveMotor(2,0.)
		self.moveMotor(3,0.)

	def open(self):
		self.moveMotor(1,0.)
		self.moveMotor(2,0.)
		self.moveMotor(3,0.)

	def close(self,amnt=0.5):
		self.moveMotor(1,amnt)
		self.moveMotor(2,amnt)
		self.moveMotor(3,amnt)

	def change_motor_min(self,index, val):
		if (index < 0 or index >= len(self.servos)):
			print ("[ERR] invalid motor index "+repr(index))
		else:
			if (index >0):
				self.motorMin[index]=val
				self.motorMax[index]=val+self.max_close
			else:	#case of the adduction motor
				self.motorMin[index]=val
				self.motorMax[index]=val+0.5
			self.reset()
			print ('Index changed successfully...')

	#abduct/adduct fingers - if no param given, move to power grasp
	def adduct(self,amnt=1):
		self.moveMotor(0,amnt)

    #abduct fingers - then pinch close
	def pinch_close(self,amnt=0.4):
		adduct_loc, enc = self.readHand()
		if(adduct_loc[0] > 0.05):
			self.reset()
			time.sleep(1.5) #pause for 1.5 seconds to allow reset
		self.moveMotor(1,amnt)
		self.moveMotor(2,amnt)

	#adduct fingers - then power close
	def power_close(self,amnt=0.6):
		adduct_loc, enc = self.readHand()
		if(adduct_loc[0] < 0.95):
			self.release()
			time.sleep(1) #pause for 1 second to allow release
			self.adduct(1)  #move fingers facing thumb
			time.sleep(1)
		self.close(amnt)

    #Example why torque control is required for fingertip manipulation
	def pinch_object_move(self,delta_amnt=0.03, left=True, down = False): #These cannot be the same or else we will move diagonal
		adduct_loc, enc = self.readHand()
		if(adduct_loc[0] > 0.05):
			print ('[ERR] Hand is not in a pinch grasp')
			return
		else:
			locs, enc = self.readHand()
			if left==True and down == False:		#move left
				self.moveMotor(1,locs[1]+delta_amnt)
				self.moveMotor(2,locs[2]-delta_amnt)
			elif left==False and down == False: 		#move right
				self.moveMotor(1,locs[1]-delta_amnt)
				self.moveMotor(2,locs[2]+delta_amnt)
			elif left==False and down == True: 		#move down
				self.moveMotor(1,locs[1]+delta_amnt)
				self.moveMotor(2,locs[2]+delta_amnt)
			else: 						#move up
				self.moveMotor(1,locs[1]-delta_amnt)
				self.moveMotor(2,locs[2]-delta_amnt)

	#replacement for preventAllLoadErrors() due to servo state constraints
	def hold(self):
		for i in [1,2]:
			amnt,enc = self.readMotor(i)
			self.modes[i] = True
			self.servos[i].apply_max_torque(self.max_torque)
			self.moveMotor(i,amnt+0.025)	#accounts for possible transition from torque mode

	#tval: torque value
	#dpos: delta in position from current (may force operation into compliance region)
	def close_torque(self,tval=None,dpos=1.0):
		if tval is None:
			tval = self.HOLD_TORQUE
		self._close_torques(tval,dpos)

	#Sets the motor into a torque mode so that fingertip manipulation is possible
	def torqueMotor(self,index,val,pos_val=None):
		val = min(1.0,max(val,0))	#by design, can exceed default max torque value
		self.modes[index] = False   #turn into torque mode
		s = self.servos[index]
		if pos_val is None:
			enc = int(s.read_encoder()+self.OVERSHOOT * s.settings['max_encoder'])
		else:
			pos_val = min(max(0,pos_val),1.0)
			enc = int((pos_val * (self.motorMax[index].modes-self.motorMin[index])+self.motorMin[index]) * s.settings['max_encoder'])

		s.apply_max_torque(val)

	#assumes operation starts with grasp w/ full contact
	#either pushing or relaxing a finger
	#shifts object to the edge of the workspace
	def shift(self,index,val, wait_range=None):
		if index != 1 and index !=2:
			print ("[ERR] Can only shift using power grasp with opposing fingers 1 and 2")
			return

		other_index=1
		if (index == 1):
			other_index=2
		vals,encs = self.readHand()

		if val<vals[index]:
			self.torqueMotor(index,0.03)
			self.moveMotor(other_index,vals[other_index]+(self.motorDir[index])*(vals[index]-val))
		else:
			self.torqueMotor(other_index,0.03)
			self.moveMotor(index,val)

		if wait_range == None:
			wait_range = 7

		for i in range(wait_range):
			s_val,s_enc = self.readMotor(index)
			s_val_err = abs(s_val-val)
			if s_val_err<0.005:
				break
			time.sleep(self.pause)

		print ("Final shift error: "+repr(round(abs(val-s_val),4)))
		self.hold()
		return s_val_err

	#demo motion that moves object back and forth with shift (assumes symmetry in operation)
	def sweep(self,val=None):
		adduct_loc, enc = self.readHand()
		if(adduct_loc[0] > 0.05):
			print ('[ERR] Hand must be in pinch_close mode before sweep')
			return

		amnts,encs = self.readHand() #record starting pose to return to
		if val == None:
			val=amnts[1]+0.10
		self.shift(1,val,7)
		time.sleep(0.5)
		self.shift(2,val,12)
		time.sleep(0.5)
		self.shift(1,val-0.05,10)
		time.sleep(0.5)
		self.shift(2,val-0.05,10)
		time.sleep(0.5)
		self.shift(1,amnts[1])
		time.sleep(self.pause)
		print ("Sweep Completed..")

	#jiggling the fingers closed. Does not work as intended
	def close_jiggle(self,amnt=0.5,da=0.05,nsteps=5,pause=0.25):
		amnt_start,amnt_enc = self.readHand()
		s_amnt = amnt_start[0]
		if s_amnt<0.5:
			print ("[WARNING] Fingers may be spread too far apart for closing motion")

		amnt_goal = np.array([amnt,amnt,amnt,s_amnt])
		da_arr = np.array([da,-da,0.,0.])
		for i in range(nsteps):
			amnt_arr = amnt_start+(amnt_goal-amnt_curr)*float(i)/nsteps+da_arr*(-1)**i

			self.moveHand(amnt_arr)
			time.sleep(pause)
		self.moveHand(amnt_goal)
